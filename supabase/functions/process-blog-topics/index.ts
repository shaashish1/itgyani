import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface BlogTopic {
  id: string;
  topic: string;
  category_id: string;
  keywords: string[];
  status: string;
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const lovableApiKey = Deno.env.get('LOVABLE_API_KEY');
    const huggingFaceToken = Deno.env.get('HUGGING_FACE_ACCESS_TOKEN');

    if (!lovableApiKey) {
      throw new Error('LOVABLE_API_KEY not configured');
    }

    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    // Get pending topics (limit to 10 at a time to avoid timeouts)
    const { data: topics, error: topicsError } = await supabase
      .from('blog_topics')
      .select('*')
      .eq('status', 'pending')
      .limit(10);

    if (topicsError) throw topicsError;
    if (!topics || topics.length === 0) {
      return new Response(
        JSON.stringify({ message: 'No pending topics to process', processed: 0 }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    const results = {
      successful: 0,
      failed: 0,
      errors: [] as string[],
    };

    for (const topic of topics as BlogTopic[]) {
      try {
        // Mark as processing
        await supabase
          .from('blog_topics')
          .update({ status: 'processing' })
          .eq('id', topic.id);

        // Get category details
        const { data: category } = await supabase
          .from('categories')
          .select('*')
          .eq('id', topic.category_id)
          .single();

        if (!category) {
          throw new Error(`Category not found for topic: ${topic.topic}`);
        }

        // Generate blog content using Lovable AI
        const prompt = `Write a comprehensive, SEO-optimized blog post about: "${topic.topic}"

Category: ${category.name}
Keywords: ${topic.keywords?.join(', ') || ''}

Requirements:
- Professional tone
- 1500-2000 words
- Include actionable insights
- Use markdown formatting
- Add relevant examples
- Optimize for SEO

Return ONLY valid JSON in this exact format:
{
  "title": "SEO-optimized title (max 60 chars)",
  "content": "Full markdown content",
  "excerpt": "Brief summary (max 160 chars)",
  "meta_description": "SEO meta description (max 160 chars)",
  "keywords": ["keyword1", "keyword2", "keyword3"],
  "tags": ["tag1", "tag2", "tag3"]
}`;

        const aiResponse = await fetch('https://ai.gateway.lovable.dev/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${lovableApiKey}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            model: 'google/gemini-2.5-flash',
            messages: [
              {
                role: 'system',
                content: 'You are an expert AI content writer. Always return valid JSON only, no additional text.'
              },
              {
                role: 'user',
                content: prompt
              }
            ],
            temperature: 0.7,
          }),
        });

        if (!aiResponse.ok) {
          const errorText = await aiResponse.text();
          throw new Error(`AI API error: ${aiResponse.status} - ${errorText}`);
        }

        const aiData = await aiResponse.json();
        const aiContent = aiData.choices?.[0]?.message?.content;

        if (!aiContent) {
          throw new Error('No content generated by AI');
        }

        // Parse AI response
        let blogData;
        try {
          const jsonMatch = aiContent.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            blogData = JSON.parse(jsonMatch[0]);
          } else {
            blogData = JSON.parse(aiContent);
          }
        } catch (parseError) {
          console.error('Failed to parse AI response:', aiContent);
          throw new Error('AI returned invalid JSON format');
        }

        // Generate slug
        const slug = blogData.title
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, '-')
          .replace(/^-|-$/g, '')
          .substring(0, 50);

        // Calculate reading time
        const wordCount = blogData.content.split(/\s+/).length;
        const readingTime = Math.ceil(wordCount / 200);

        // Insert blog post
        const { data: newPost, error: insertError } = await supabase
          .from('blog_posts')
          .insert({
            title: blogData.title,
            slug: `${slug}-${Date.now()}`,
            content: blogData.content,
            excerpt: blogData.excerpt,
            category_id: topic.category_id,
            meta_title: blogData.title,
            meta_description: blogData.meta_description,
            keywords: blogData.keywords || topic.keywords,
            tags: blogData.tags || [],
            reading_time: readingTime,
            status: 'published',
            published_at: new Date().toISOString(),
          })
          .select()
          .single();

        if (insertError) throw insertError;

        // Log generation
        await supabase.from('ai_generation_logs').insert({
          blog_post_id: newPost.id,
          model_used: 'google/gemini-2.5-flash',
          prompt: prompt.substring(0, 500),
          tokens_used: aiData.usage?.total_tokens || 0,
          status: 'success',
        });

        // Mark topic as processed
        await supabase
          .from('blog_topics')
          .update({ 
            status: 'processed',
            processed_at: new Date().toISOString()
          })
          .eq('id', topic.id);

        results.successful++;

        // Small delay between requests
        await new Promise(resolve => setTimeout(resolve, 2000));

      } catch (error) {
        console.error(`Error processing topic ${topic.topic}:`, error);
        results.failed++;
        results.errors.push(`${topic.topic}: ${error.message}`);

        // Mark topic as failed
        await supabase
          .from('blog_topics')
          .update({ 
            status: 'failed',
            error_message: error.message
          })
          .eq('id', topic.id);
      }
    }

    return new Response(
      JSON.stringify({
        message: 'Blog topics processing complete',
        ...results,
        total: topics.length,
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );

  } catch (error) {
    console.error('Error in process-blog-topics:', error);
    return new Response(
      JSON.stringify({ error: error.message }),
      { 
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      }
    );
  }
});
